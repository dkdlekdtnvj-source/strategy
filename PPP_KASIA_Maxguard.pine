//@version=5
strategy("PPP 비시바 알고 - KASIA 통합 맥스가드",
     overlay=true, max_labels_count=500, max_lines_count=500,
     initial_capital=10000, currency=currency.USD,
     commission_type=strategy.commission.percent, commission_value=0.05,
     slippage=0, calc_on_every_tick=true, calc_on_order_fills=true,
     process_orders_on_close=false, pyramiding=5,
     default_qty_type=strategy.fixed, default_qty_value=1)

// =====================================================================
// KASIA Base Module v3.0 (통합형) - 시간/리스크/가드/HUD/컨텍스트
// =====================================================================

var GRP_TIME   = "A) 시간 & 세션"
var GRP_RISK   = "B) 리스크 & 월렛"
var GRP_GUARD  = "C) 자본/거래 가드"
var GRP_CTX    = "D) 시장 컨텍스트 필터"
var GRP_FILTER = "E) 모멘텀/구조 필터"
var GRP_SL     = "F) 손절 & 유틸"
var GRP_HUD    = "G) HUD & 디버거"
var GRP_DEMO   = "H) 데모 테스트 로직"

// ---- 시간 & 세션 ----
startYear   = input.int(2024, "백테스트 시작 연도", minval=2017, group=GRP_TIME)
startMonth  = input.int(1,   "백테스트 시작 월",   minval=1, maxval=12, group=GRP_TIME)
startDay    = input.int(1,   "백테스트 시작 일",   minval=1, maxval=31, group=GRP_TIME)
startTs     = timestamp(syminfo.timezone, startYear, startMonth, startDay, 0, 0)

useSessionFilter = input.bool(true, "기본 세션 필터 사용", group=GRP_TIME)
primarySession   = input.session("0830-0200", "기본 세션 (거래소 로컬)", group=GRP_TIME)

useKstSession = input.bool(true, "한국시간 세션 필터", group=GRP_TIME)
kstSession   = input.session("0930-0200", "한국시간 세션", group=GRP_TIME)

useDayFilter = input.bool(true, "요일 필터 사용", group=GRP_TIME)
monOk = input.bool(true,  "월", inline="dow1", group=GRP_TIME)
tueOk = input.bool(true,  "화", inline="dow1", group=GRP_TIME)
wedOk = input.bool(true,  "수", inline="dow1", group=GRP_TIME)
thuOk = input.bool(true,  "목", inline="dow1", group=GRP_TIME)
friOk = input.bool(true,  "금", inline="dow2", group=GRP_TIME)
satOk = input.bool(false, "토", inline="dow2", group=GRP_TIME)
sunOk = input.bool(false, "일", inline="dow2", group=GRP_TIME)

// ---- 리스크 & 월렛 ----
positionSizingMode = input.string("Risk-Based", "사이징 엔진", options=["Risk-Based", "Notional"], group=GRP_RISK)
riskSizingType     = input.string("Fixed Fractional", "리스크 포지션 타입", options=["Fixed Fractional", "Fixed Lot"], group=GRP_RISK)
baseRiskPct        = input.float(0.6, "기본 리스크 %", step=0.05, minval=0.1, group=GRP_RISK)
fixedContractSize  = input.float(1.0, "고정 계약 수량", step=0.1, minval=0.001, group=GRP_RISK)

leverage           = input.float(15.0, "레버리지", minval=1, maxval=50, step=0.1, group=GRP_RISK)
slipTicks          = input.int(1, "슬리피지 (틱)", minval=0, maxval=50, group=GRP_RISK)
var float tickSize = syminfo.mintick
slipBuffer         = tickSize * slipTicks

notionalSizingType  = input.string("Equity %", "노션널 기준", options=["Fixed USD", "Equity %"], group=GRP_RISK)
notionalSizingValue = input.float(80.0, "노션널 값 (USD 또는 %)", minval=1, group=GRP_RISK)

useWallet          = input.bool(true, "월렛 시스템 사용", group=GRP_RISK)
profitReservePct   = input.float(20.0, "수익 적립 비율 %", minval=0.0, maxval=100.0, step=1.0, group=GRP_RISK) / 100.0
applyReserveToSizing = input.bool(true, "적립금 제외 후 사이징", group=GRP_RISK)
minTradableCapital = input.float(300.0, "최소 거래 가능 자본 ($)", minval=50, group=GRP_RISK)

useDrawdownScaling  = input.bool(true, "드로우다운 리스크 축소", group=GRP_RISK)
drawdownTriggerPct  = input.float(7.0, "드로우다운 트리거 %", minval=1, maxval=50, group=GRP_RISK)
drawdownRiskScale   = input.float(0.5, "드로우다운 리스크 배율", minval=0.1, maxval=1.0, step=0.05, group=GRP_RISK)

usePerfAdaptiveRisk = input.bool(true, "성과 적응 리스크 (PAR)", group=GRP_RISK)
parLookback         = input.int(6, "PAR 거래 수 집계", minval=2, maxval=20, group=GRP_RISK)
parMinTrades        = input.int(3, "PAR 최소 거래 수", minval=1, maxval=20, group=GRP_RISK)
parHotWinRate       = input.float(65.0, "핫스트릭 승률 %", minval=40, maxval=90, step=0.5, group=GRP_RISK)
parColdWinRate      = input.float(35.0, "콜드스트릭 승률 %", minval=5, maxval=60, step=0.5, group=GRP_RISK)
parHotRiskMult      = input.float(1.25, "핫스트릭 리스크 배율", minval=1.0, maxval=2.0, step=0.05, group=GRP_RISK)
parColdRiskMult     = input.float(0.35, "콜드스트릭 리스크 배율", minval=0.0, maxval=1.0, step=0.05, group=GRP_RISK)
parPauseOnCold      = input.bool(true, "콜드스트릭 시 진입 중지", group=GRP_RISK)

// ---- 자본/거래 가드 ----
useCapitalGuard     = input.bool(true, "자본 가드", group=GRP_GUARD)
capitalGuardPct     = input.float(18.0, "자본 드로우다운 한도 %", minval=1, maxval=100, step=1, group=GRP_GUARD)

useDailyLossGuard   = input.bool(true, "일일 손실 가드", group=GRP_GUARD)
dailyLossThreshold  = input.float(80, "일일 손실 한도 ($)", minval=10, group=GRP_GUARD)
useDailyProfitLock  = input.bool(true, "일일 이익 잠금", group=GRP_GUARD)
dailyProfitTarget   = input.float(120, "일일 이익 목표 ($)", minval=0, group=GRP_GUARD)
useWeeklyProfitLock = input.bool(true, "주간 이익 잠금", group=GRP_GUARD)
weeklyProfitTarget  = input.float(250, "주간 이익 목표 ($)", minval=0, group=GRP_GUARD)

useLossStreakGuard  = input.bool(true, "연패 중지 가드", group=GRP_GUARD)
maxConsecutiveLosses = input.int(3, "최대 연속 손실 횟수", minval=1, maxval=10, group=GRP_GUARD)

useGuardExit        = input.bool(true, "청산가 선제 가드", group=GRP_GUARD)
maintenanceMarginPct = input.float(0.5, "유지 증거금 %", minval=0.1, step=0.05, group=GRP_GUARD)
preemptTicks        = input.int(8, "선제 청산 틱", minval=0, maxval=50, group=GRP_GUARD)

maxDailyLosses      = input.int(3, "일일 최대 손실 거래 수", minval=0, group=GRP_GUARD)
maxWeeklyDD         = input.float(9.0, "주간 최대 드로우다운 %", minval=0, group=GRP_GUARD)
maxGuardFires       = input.int(4, "청산 가드 최대 발동", minval=0, group=GRP_GUARD)

useVolatilityGuard  = input.bool(true, "ATR 변동성 가드", group=GRP_GUARD)
volatilityLookback  = input.int(50, "ATR %% 기간", minval=10, maxval=200, group=GRP_GUARD)
volatilityLowerPct  = input.float(0.15, "ATR %% 하한", minval=0.05, step=0.05, group=GRP_GUARD)
volatilityUpperPct  = input.float(2.5, "ATR %% 상한", minval=0.2, step=0.05, group=GRP_GUARD)

// ---- 시장 컨텍스트 필터 ----
useRegimeFilter = input.bool(true, "상위봉 레짐 필터", group=GRP_CTX)
htfTf           = input.timeframe("240", "상위봉 타임프레임", group=GRP_CTX)
htfEmaLen       = input.int(120, "상위봉 EMA 길이", minval=20, maxval=400, group=GRP_CTX)
htfAdxLen       = input.int(14, "상위봉 ADX 길이", minval=5, maxval=50, group=GRP_CTX)
htfAdxTh        = input.float(22, "상위봉 ADX 임계값", minval=5, maxval=50, step=0.5, group=GRP_CTX)
htfRsiLen       = input.int(21, "상위봉 RSI 길이", minval=5, maxval=50, group=GRP_CTX)

useVWAPFilter   = input.bool(true, "VWAP 필터", group=GRP_CTX)
useMicroTrend   = input.bool(true, "EMA 클라우드 (Micro Trend)", group=GRP_CTX)
emaFastLenBase  = input.int(21, "EMA 빠른선 기본", minval=5, maxval=100, group=GRP_CTX)
emaSlowLenBase  = input.int(55, "EMA 느린선 기본", minval=10, maxval=200, group=GRP_CTX)

useRangeFilter  = input.bool(true, "레인지 차단", group=GRP_CTX)
rangeLen        = input.int(36, "레인지 기준 봉수", minval=5, maxval=200, group=GRP_CTX)
rangeAtrMult    = input.float(1.4, "레인지 ATR 배수", minval=0.5, maxval=5, step=0.1, group=GRP_CTX)

useDistanceGuard = input.bool(true, "가격 이격 가드", group=GRP_CTX)
distanceAtrLen   = input.int(21, "이격 ATR 길이", minval=5, maxval=200, group=GRP_CTX)
distanceMaxAtr   = input.float(2.4, "최대 이격 (ATR)", minval=0.5, maxval=5, step=0.1, group=GRP_CTX)

useSlopeFilter   = input.bool(true, "EMA 기울기 필터", group=GRP_CTX)
slopeLookback    = input.int(8, "기울기 룩백", minval=1, maxval=50, group=GRP_CTX)
slopeMinPct      = input.float(0.06, "최소 기울기 (%)", minval=0.0, maxval=1.0, step=0.01, group=GRP_CTX)

useTrendBias     = input.bool(true, "추세 EMA 필터", group=GRP_CTX)
trendLenBase     = input.int(200, "추세 EMA 기본", minval=20, maxval=400, group=GRP_CTX)
useConfBias      = input.bool(true, "확인 EMA 필터", group=GRP_CTX)
confLenBase      = input.int(55, "확인 EMA 기본", minval=10, maxval=300, group=GRP_CTX)

// ---- 모멘텀/구조 필터 ----
useMomConfirm   = input.bool(true, "모멘텀 확증 사용", group=GRP_FILTER)
bbLen           = input.int(18, "볼린저 길이", minval=10, maxval=100, group=GRP_FILTER)
bbMult          = input.float(1.2, "볼린저 배수", minval=0.5, maxval=5, step=0.1, group=GRP_FILTER)
kcLen           = input.int(21, "켈트너 길이", minval=10, maxval=100, group=GRP_FILTER)

useCHoCH        = input.bool(true, "CHoCH 확인 사용", group=GRP_FILTER)
pL              = input.int(2, "피벗 좌", minval=1, maxval=20, group=GRP_FILTER)
pR              = input.int(3, "피벗 우", minval=1, maxval=20, group=GRP_FILTER)

useVolumeFilter = input.bool(true, "거래량 스파이크 필터", group=GRP_FILTER)
volumeLookback  = input.int(34, "거래량 평균 기간", minval=5, maxval=200, group=GRP_FILTER)
volumeMultiplier = input.float(1.3, "거래량 배수", minval=1.0, maxval=5.0, step=0.1, group=GRP_FILTER)

useCandleFilter = input.bool(true, "캔들 모멘텀 필터", group=GRP_FILTER)
candleBodyRatio = input.float(55, "몸통 비율 %", minval=10, maxval=99, step=1, group=GRP_FILTER)

useRSIShift     = input.bool(true, "상위봉 RSI 바이어스", group=GRP_FILTER)
rsiBullBand     = input.float(52, "RSI 강세 기준", minval=40, maxval=70, step=0.5, group=GRP_FILTER)
rsiBearBand     = input.float(48, "RSI 약세 기준", minval=30, maxval=60, step=0.5, group=GRP_FILTER)

useEquitySlopeFilter = input.bool(true, "순자산 기울기 필터", group=GRP_FILTER)
eqSlopeLen      = input.int(120, "순자산 기울기 길이", minval=20, maxval=500, group=GRP_FILTER)

// ---- 손절 & 유틸 ----
usePivotSL    = input.bool(true, "피벗 손절 사용", group=GRP_SL)
pivLeft       = input.int(4, "피벗 좌", minval=1, maxval=20, group=GRP_SL)
pivRight      = input.int(4, "피벗 우", minval=1, maxval=20, group=GRP_SL)
atrLenSL      = input.int(14, "ATR 손절 길이", minval=5, maxval=100, group=GRP_SL)
atrBufferMult = input.float(0.25, "ATR 버퍼 배수", minval=0, maxval=2, step=0.05, group=GRP_SL)

// ---- HUD & 디버거 ----
showHUD       = input.bool(true, "HUD 표시", group=GRP_HUD)
showDebugger  = input.bool(true, "디버거 표시", group=GRP_HUD)
hudPosition   = input.string("Top Right", "HUD 위치", options=["Top Left", "Top Right", "Middle Left", "Middle Right", "Bottom Left", "Bottom Right"], group=GRP_HUD)

eodClose      = input.bool(true, "세션 종료 시 청산", group=GRP_HUD)
eodTime       = input.string("02:05", "청산 시간 (HH:MM)", group=GRP_HUD)

// ---- 데모 테스트 로직 ----
useDemoLogic = input.bool(false, "데모 RSI 진입 로직 실행", group=GRP_DEMO)
rsiLenDemo   = input.int(14, "데모 RSI 길이", group=GRP_DEMO, minval=1)

// =====================================================================
// PPP Vishva Algo 핵심 입력 (UT Bot / StochRSI / 구조)
// =====================================================================

var GRP_PPP_PRESET = "I) PPP 프리셋 튜너"
var GRP_PPP_TIME = "J) PPP 타임프레임"
var GRP_PPP_UT   = "K) PPP UT Bot"
var GRP_PPP_STO  = "L) PPP StochRSI"
var GRP_PPP_TREND= "M) PPP 추세 필터"
var GRP_PPP_EXIT = "N) PPP 청산"
var GRP_PPP_ADV  = "O) PPP 고급 필터"
var GRP_PPP_RISK = "P) PPP 리스크"

presetMode = input.string("사용자", "프리셋 모드", options=["사용자", "1분 초단타", "3분 표준", "5분 스윙"], group=GRP_PPP_PRESET,
     tooltip="프리셋 선택 시 주요 UT/스톱/ROI 매개변수가 해당 시간프레임에 맞춰 자동 튜닝됩니다.")

// --- PPP 타임프레임 입력 ---
tf_stoch= input.timeframe("15", "StochRSI TF", group=GRP_PPP_TIME)
tf_htf1 = input.timeframe("60", "HTF-1 (Trend/EMA20+HA)", group=GRP_PPP_TIME)
tf_htf2 = input.timeframe("D",  "HTF-2 (Trend/EMA20+HA)", group=GRP_PPP_TIME)
useReg  = input.bool(true, "BTC 레짐 필터 사용", group=GRP_PPP_TIME)
regSym  = input.symbol("BINANCE:BTCUSDT", "레짐 심볼", group=GRP_PPP_TIME)
regTF   = input.timeframe("D", "레짐 TF (EMA200+ADX)", group=GRP_PPP_TIME)
regADX  = input.int(20, "레짐 ADX ≥", 5, 50, group=GRP_PPP_TIME)

// --- PPP UT Bot ---
noRP  = input.bool(true, "확정봉 신호만 사용", group=GRP_PPP_UT)
ibs   = input.bool(false, "Intrabar Safe 모드", group=GRP_PPP_UT, tooltip="동일 봉 내 재진입 방지")
utKey = input.float(4.0, "UT Key (ATR 배수)", 0.5, 10, 0.1, group=GRP_PPP_UT)
utATR = input.int(10, "UT ATR 기간", 1, 100, group=GRP_PPP_UT)
utHA  = input.bool(false, "UT에 Heikin-Ashi 사용", group=GRP_PPP_UT)

// --- PPP StochRSI ---
rsiLen= input.int(14, "RSI 길이", 2, 100, group=GRP_PPP_STO)
stLen = input.int(14, "Stoch 길이", 2, 100, group=GRP_PPP_STO)
kLen  = input.int(3, "%K", 1, 50, group=GRP_PPP_STO)
dLen  = input.int(3, "%D", 1, 50, group=GRP_PPP_STO)
ob    = input.float(80, "과매수", 50, 100, group=GRP_PPP_STO)
os    = input.float(20, "과매도", 0, 50, group=GRP_PPP_STO)
stMode= input.string("Bounce", "시그널 모드", options=["Bounce","Cross"], group=GRP_PPP_STO)

// --- PPP 추세 필터 ---
useMA100 = input.bool(true, "현재 TF MA100 필터", group=GRP_PPP_TREND)
maType    = input.string("EMA", "MA100 유형", options=["EMA","SMA","WMA"], group=GRP_PPP_TREND)

// --- PPP 청산 ---
atrLen= input.int(14, "ATR 길이", 1, 100, group=GRP_PPP_EXIT)
initK = input.float(1.8, "초기 손절 = k*ATR", 0.5, 5, 0.1, group=GRP_PPP_EXIT)
tp1RR = input.float(1.0, "TP1 = 1R", 0.5, 5, 0.1, group=GRP_PPP_EXIT)
tp2RR = input.float(2.0, "TP2 = 2R", 0.5, 10, 0.1, group=GRP_PPP_EXIT)
tp1Pct= input.float(50, "TP1 청산 비중 %", 1, 99, group=GRP_PPP_EXIT)
trailK= input.float(2.5, "TP1 이후 ATR 트레일", 0.5, 8, 0.1, group=GRP_PPP_EXIT)
useSwingSL=input.bool(false, "스윙 저/고점 손절 사용", group=GRP_PPP_EXIT)
swN   = input.int(5, "스윙 룩백", 2, 20, group=GRP_PPP_EXIT)
beOffsetPct = input.float(0.0, "브레이크이븐 오프셋 %", 0.0, 2.0, 0.01, group=GRP_PPP_EXIT)
maxBarsHold = input.int(0, "최대 보유 봉수 (0=비활성)", 0, 5000, group=GRP_PPP_EXIT)
usePercentStops = input.bool(true, "퍼센트 손절/익절 병행", group=GRP_PPP_EXIT)
stopPct   = input.float(1.5, "고정 손절 %", 0.1, 20, 0.1, group=GRP_PPP_EXIT)
takePct   = input.float(2.5, "고정 익절 %", 0.1, 40, 0.1, group=GRP_PPP_EXIT)
trailStartPct = input.float(1.0, "트레일 시작 수익 %", 0.1, 20, 0.1, group=GRP_PPP_EXIT)
trailGapPct   = input.float(0.5, "트레일 간격 %", 0.1, 10, 0.05, group=GRP_PPP_EXIT)
utFlipExit    = input.bool(true, "UT 반대 신호 청산", group=GRP_PPP_EXIT)

roi1Min = input.int(50, "ROI1 경과 분", 0, 1000, group=GRP_PPP_EXIT)
roi1Pct = input.float(2.4, "ROI1 목표 %", 0.0, 50, 0.1, group=GRP_PPP_EXIT)
roi2Min = input.int(100, "ROI2 경과 분", 0, 1000, group=GRP_PPP_EXIT)
roi2Pct = input.float(2.0, "ROI2 목표 %", 0.0, 50, 0.1, group=GRP_PPP_EXIT)
roi3Min = input.int(150, "ROI3 경과 분", 0, 1000, group=GRP_PPP_EXIT)
roi3Pct = input.float(1.6, "ROI3 목표 %", 0.0, 50, 0.1, group=GRP_PPP_EXIT)

// --- PPP 고급 필터 ---
useEWO     = input.bool(true, "EWO 컨펌", group=GRP_PPP_ADV)
ewoFast    = input.int(16, "EWO 빠른 EMA", 1, 200, group=GRP_PPP_ADV)
ewoSlow    = input.int(26, "EWO 느린 EMA", 2, 400, group=GRP_PPP_ADV)
ewoSignal  = input.int(9, "EWO 시그널", 1, 100, group=GRP_PPP_ADV)
useChop    = input.bool(true, "Choppiness 필터", group=GRP_PPP_ADV)
chopLen    = input.int(14, "Chop 길이", 5, 100, group=GRP_PPP_ADV)
chopMax    = input.float(61.8, "허용 Chop 최대", 30, 70, group=GRP_PPP_ADV)
useVolatility = input.bool(true, "추가 ATR% 필터", group=GRP_PPP_ADV)
minAtrPerc    = input.float(0.8, "최소 ATR%", 0.1, 20, 0.1, group=GRP_PPP_ADV)
maxAtrPerc    = input.float(8.0, "최대 ATR%", 0.2, 50, 0.1, group=GRP_PPP_ADV)
useVolumeBoost = input.bool(true, "거래량 필터", group=GRP_PPP_ADV)
volLen          = input.int(20, "거래량 SMA", 1, 200, group=GRP_PPP_ADV)
useStructure    = input.bool(true, "최근 고/저 돌파 요구", group=GRP_PPP_ADV)
structureLen    = input.int(20, "구조 룩백", 5, 200, group=GRP_PPP_ADV)

// --- PPP 리스크 ---
minQty       = input.float(0.001, "최소 주문 수량", 0.0, 10, 0.001, group=GRP_PPP_RISK)
profitLockPct= input.float(1.5, "일일 이익 잠금 % (기존)", 0.0, 20, 0.1, group=GRP_PPP_RISK)
maxTradesPerDay = input.int(0, "일일 최대 신규 진입 (0=무제한)", 0, 50, group=GRP_PPP_RISK)
lossCooldownBars = input.int(10, "손실 후 쿨다운 봉", 0, 500, group=GRP_PPP_RISK)

presetSelect(userValue, scalperValue, baseValue, swingValue)=>
     presetMode == "사용자" ? userValue :
     presetMode == "1분 초단타" ? scalperValue :
     presetMode == "3분 표준" ? baseValue : swingValue

utKeyEff      = presetSelect(utKey, 3.0, 4.0, 4.6)
utAtrEff      = presetSelect(utATR, 8, 10, 14)
obEff         = presetSelect(ob, 75.0, 80.0, 82.0)
osEff         = presetSelect(os, 25.0, 20.0, 18.0)
tp1PctEff     = presetSelect(tp1Pct, 60.0, 50.0, 40.0)
initKEff      = presetSelect(initK, 1.5, 1.8, 2.2)
tp1RREff      = presetSelect(tp1RR, 0.9, 1.0, 1.2)
tp2RREff      = presetSelect(tp2RR, 1.6, 2.0, 2.4)
trailKEff     = presetSelect(trailK, 2.0, 2.5, 3.0)
beOffsetEff   = presetSelect(beOffsetPct, 0.1, 0.0, 0.0)
maxBarsHoldEff= presetSelect(maxBarsHold, 240, 160, 120)
stopPctEff    = presetSelect(stopPct, 1.0, 1.5, 1.9)
takePctEff    = presetSelect(takePct, 1.6, 2.5, 3.2)
trailStartEff = presetSelect(trailStartPct, 0.7, 1.0, 1.3)
trailGapEff   = presetSelect(trailGapPct, 0.25, 0.5, 0.8)
roi1MinEff    = presetSelect(roi1Min, 15, 50, 90)
roi1PctEff    = presetSelect(roi1Pct, 1.4, 2.4, 3.0)
roi2MinEff    = presetSelect(roi2Min, 40, 100, 160)
roi2PctEff    = presetSelect(roi2Pct, 1.1, 2.0, 2.6)
roi3MinEff    = presetSelect(roi3Min, 70, 150, 220)
roi3PctEff    = presetSelect(roi3Pct, 0.9, 1.6, 2.2)
// =====================================================================
// 공통 헬퍼 함수
// =====================================================================

ma(src, typ, len)=> typ=="EMA"?ta.ema(src,len):typ=="SMA"?ta.sma(src,len):ta.wma(src,len)
calcEWO(src, fast, slow)=> ta.ema(src, fast) - ta.ema(src, slow)
calcChop(len)=>
    trVal = ta.tr(true)
    trSum = math.sum(trVal, len)
    highestVal = ta.highest(high, len)
    lowestVal  = ta.lowest(low, len)
    priceSpan  = highestVal - lowestVal
    denom      = priceSpan == 0.0 ? nz(trVal) : priceSpan
    100 * math.log10(trSum / denom) / math.log10(len)
calcAtrPerc(len)=> ta.atr(len) / close * 100

f_adx(len) =>
    [_, _, adx] = ta.dmi(high, low, len)
    adx

var haTicker = ticker.heikinashi(syminfo.tickerid)

haClose(tf)=> request.security(haTicker, tf, close, lookahead=barmerge.lookahead_off)
ema20(tf)  => request.security(syminfo.tickerid, tf, ta.ema(close,20), lookahead=barmerge.lookahead_off)

f_str(val) => str.tostring(val, format.mintick)

f_cell(tbl, c, r, ok) =>
    bg = ok ? color.new(color.green, 80) : color.new(color.red, 80)
    table.cell(tbl, c, r, ok ? "OK" : "X", bgcolor=bg, text_color=color.white)

// =====================================================================
// KASIA Base Module 계산 로직
// =====================================================================

inDate = time >= startTs
sessionAllowed   = not useSessionFilter or not na(time(timeframe.period, primarySession))
kstAllowed       = not useKstSession or not na(time(timeframe.period, kstSession, "Asia/Seoul"))

dayChar = dayofweek == dayofweek.monday ? "월" :
     dayofweek == dayofweek.tuesday ? "화" :
     dayofweek == dayofweek.wednesday ? "수" :
     dayofweek == dayofweek.thursday ? "목" :
     dayofweek == dayofweek.friday ? "금" :
     dayofweek == dayofweek.saturday ? "토" : "일"

dayAllowed = not useDayFilter or (
     (dayChar == "월" and monOk) or (dayChar == "화" and tueOk) or (dayChar == "수" and wedOk) or
     (dayChar == "목" and thuOk) or (dayChar == "금" and friOk) or (dayChar == "토" and satOk) or
     (dayChar == "일" and sunOk))

var float tradableCapital = strategy.initial_capital
var float withdrawable    = 0.0
var float peakEquity      = strategy.initial_capital

if barstate.isconfirmed
    newProfit = strategy.netprofit - nz(strategy.netprofit[1])
    if useWallet and newProfit > 0
        withdrawable += newProfit * profitReservePct
    effectiveEquity = useWallet and applyReserveToSizing ? strategy.equity - withdrawable : strategy.equity
    tradableCapital := math.max(effectiveEquity, strategy.initial_capital * 0.01)
    peakEquity := math.max(peakEquity, strategy.equity)

currentDD      = peakEquity > 0 ? (peakEquity - strategy.equity) / peakEquity * 100 : 0.0
scaledRiskPct  = useDrawdownScaling and currentDD > drawdownTriggerPct ? baseRiskPct * drawdownRiskScale : baseRiskPct

var recentTradeResults = array.new_float()
var int lastClosedCount = 0
closedCount = strategy.closedtrades
if usePerfAdaptiveRisk and closedCount > lastClosedCount
    for idx = lastClosedCount to closedCount - 1
        tradeProfit = strategy.closedtrades.profit(idx)
        array.push(recentTradeResults, tradeProfit)
        if array.size(recentTradeResults) > parLookback
            array.shift(recentTradeResults)
    lastClosedCount := closedCount
else if not usePerfAdaptiveRisk
    lastClosedCount := closedCount

recentTrades = array.size(recentTradeResults)
recentWins   = 0
if usePerfAdaptiveRisk and recentTrades > 0
    for i = 0 to recentTrades - 1
        plTrade = array.get(recentTradeResults, i)
        recentWins += plTrade > 0 ? 1 : 0
recentWinRate = usePerfAdaptiveRisk and recentTrades > 0 ? recentWins / recentTrades * 100.0 : na
isHotStreak   = usePerfAdaptiveRisk and not na(recentWinRate) and recentTrades >= parMinTrades and recentWinRate >= parHotWinRate
isColdStreak  = usePerfAdaptiveRisk and not na(recentWinRate) and recentTrades >= parMinTrades and recentWinRate <= parColdWinRate
perfRiskMult  = usePerfAdaptiveRisk ? (isHotStreak ? parHotRiskMult : isColdStreak ? parColdRiskMult : 1.0) : 1.0
finalRiskPct  = scaledRiskPct * perfRiskMult

parStateLabel = not usePerfAdaptiveRisk ? "OFF" : isHotStreak ? "HOT" : isColdStreak ? "COLD" : "NEUTRAL"
parWinLabel   = na(recentWinRate) ? "-" : str.tostring(recentWinRate, "##.##") + "%"

useVolGuardRange(float atrPctVal) => not useVolatilityGuard or (atrPctVal >= volatilityLowerPct and atrPctVal <= volatilityUpperPct)

var float dailyStartCapital = tradableCapital
var float dailyPeakCapital  = tradableCapital
var bool  isGuardHalted     = false
var int guardFiredTotal   = 0
var int dailyLosses       = 0
var float weekPeakEquity  = strategy.initial_capital
var float weekStartEquity = strategy.initial_capital
var int lossStreak        = 0

atrStop = ta.atr(atrLenSL)
atrForPct = ta.atr(volatilityLookback)
atrPct  = close != 0 ? atrForPct / close * 100.0 : 0.0
isVolatilityOK = useVolGuardRange(atrPct)

aNewDay = ta.change(dayofmonth) != 0
if aNewDay
    dailyStartCapital := tradableCapital
    dailyPeakCapital  := tradableCapital
    isGuardHalted     := false
    dailyLosses       := 0

aNewWeek = ta.change(weekofyear) != 0
if aNewWeek
    weekPeakEquity  := strategy.equity
    weekStartEquity := strategy.equity
else
    weekPeakEquity := math.max(weekPeakEquity, strategy.equity)

dailyPeakCapital := math.max(dailyPeakCapital, tradableCapital)
dailyPnl         = tradableCapital - dailyStartCapital
weeklyDD         = weekPeakEquity > 0 ? (weekPeakEquity - strategy.equity) / weekPeakEquity * 100.0 : 0.0
weeklyPnl        = strategy.equity - weekStartEquity

isDailyLossBreached = useDailyLossGuard and dailyPnl <= -dailyLossThreshold
if isDailyLossBreached
    isGuardHalted := true

dailyProfitReached  = useDailyProfitLock and dailyPnl >= dailyProfitTarget
weeklyProfitReached = useWeeklyProfitLock and weeklyPnl >= weeklyProfitTarget

if strategy.losstrades > strategy.losstrades[1]
    dailyLosses += 1
    lossStreak  += 1
if strategy.wintrades > strategy.wintrades[1]
    lossStreak := 0

kasia_guard_price(entryPrice, direction, qty) =>
    if qty == 0.0
        entryPrice
    else
        initialMargin = (qty * entryPrice) / leverage
        maintMargin   = (qty * entryPrice) * (maintenanceMarginPct / 100.0)
        offset        = (initialMargin - maintMargin) / qty
        direction == 1 ? entryPrice - offset : entryPrice + offset

if useGuardExit and strategy.position_size != 0
    guardEntryPrice = strategy.position_avg_price
    guardDirection  = strategy.position_size > 0 ? 1 : -1
    guardQty        = math.abs(strategy.position_size)
    liqPrice        = kasia_guard_price(guardEntryPrice, guardDirection, guardQty)
    preemptPrice    = guardDirection == 1 ? liqPrice + preemptTicks * tickSize : liqPrice - preemptTicks * tickSize
    hitGuard        = guardDirection == 1 ? low <= preemptPrice : high >= preemptPrice
    if hitGuard
        strategy.close_all(comment="Guard Exit")
        guardFiredTotal += 1

stop_by_losses = maxDailyLosses > 0 and dailyLosses >= maxDailyLosses
stop_by_dd     = maxWeeklyDD > 0 and weeklyDD >= maxWeeklyDD
stop_by_guard  = maxGuardFires > 0 and guardFiredTotal >= maxGuardFires
stop_by_capital = tradableCapital < minTradableCapital
stop_by_streak  = useLossStreakGuard and lossStreak >= maxConsecutiveLosses
stop_by_perf    = usePerfAdaptiveRisk and parPauseOnCold and isColdStreak
stop_by_profit  = dailyProfitReached or weeklyProfitReached

isCapitalBreached = useCapitalGuard and strategy.equity < strategy.initial_capital * (1 - capitalGuardPct / 100.0)

htfRsiSeries = request.security(syminfo.tickerid, htfTf, ta.rsi(close, htfRsiLen))
htfRsi       = htfRsiSeries[1]

emaFast = ta.ema(close, emaFastLenBase)
emaSlow = ta.ema(close, emaSlowLenBase)
microTrendLong = not useMicroTrend or emaFast > emaSlow
microTrendShort = not useMicroTrend or emaFast < emaSlow

maTrend = ta.ema(close, trendLenBase)
maConf  = ta.ema(close, confLenBase)
trendBiasLongOK  = not useTrendBias or close > maTrend
trendBiasShortOK = not useTrendBias or close < maTrend
confBiasLongOK   = not useConfBias or close > maConf
confBiasShortOK  = not useConfBias or close < maConf

prevTrend = nz(maTrend[slopeLookback], maTrend)
slopePct  = maTrend != 0 ? (maTrend - prevTrend) / maTrend * 100.0 : 0.0
slopeOK_L = not useSlopeFilter or slopePct >= slopeMinPct
slopeOK_S = not useSlopeFilter or slopePct <= -slopeMinPct

rangeHigh = ta.highest(high, rangeLen)
rangeLow  = ta.lowest(low, rangeLen)
rangeAtr  = ta.atr(rangeLen)
isRanging = (rangeHigh - rangeLow) < rangeAtr * rangeAtrMult
rangeOK   = not useRangeFilter or not isRanging

htfEmaSeries = request.security(syminfo.tickerid, htfTf, ta.ema(close, htfEmaLen))
htfEma       = htfEmaSeries[1]
htfAdxSeries = request.security(syminfo.tickerid, htfTf, f_adx(htfAdxLen))
htfAdx       = htfAdxSeries[1]

htfLong = not useRegimeFilter or (close > htfEma and htfAdx > htfAdxTh)
htfShort = not useRegimeFilter or (close < htfEma and htfAdx > htfAdxTh)

vwap = ta.vwap
vwapLong  = not useVWAPFilter or close >= vwap
vwapShort = not useVWAPFilter or close <= vwap

atrDistance = ta.atr(distanceAtrLen)
vwDistance  = atrDistance > 0 ? math.abs(close - vwap) / atrDistance : 0.0
trendDistance = atrDistance > 0 ? math.abs(close - maTrend) / atrDistance : 0.0

distanceOK_L = not useDistanceGuard or (vwDistance <= distanceMaxAtr and trendDistance <= distanceMaxAtr)
distanceOK_S = distanceOK_L

bbBasis = ta.sma(close, bbLen)
bbDev   = bbMult * ta.stdev(close, bbLen)
bbUpper = bbBasis + bbDev
bbLower = bbBasis - bbDev
kcRange = ta.atr(kcLen) * bbMult
squeezeOn = (bbUpper - bbLower) < kcRange
mom = ta.linreg(close - bbBasis, 14, 0)
momOK_L = not useMomConfirm or (mom > 0 and (not squeezeOn or ta.crossover(mom, 0)))
momOK_S = not useMomConfirm or (mom < 0 and (not squeezeOn or ta.crossunder(mom, 0)))

ph = ta.pivothigh(high, pL, pR)
pl = ta.pivotlow(low, pL, pR)
lastHigh = ta.valuewhen(not na(ph), ph, 0)
lastLow  = ta.valuewhen(not na(pl), pl, 0)
bullCHoCH = not na(lastHigh) and not na(lastLow) and close > lastHigh and low > lastLow
bearCHoCH = not na(lastHigh) and not na(lastLow) and close < lastLow and high < lastHigh
chochOK_L = not useCHoCH or bullCHoCH
chochOK_S = not useCHoCH or bearCHoCH

volSma         = ta.sma(volume, volumeLookback)
isVolumeSpike  = volSma > 0 ? volume >= volSma * volumeMultiplier : false
volumeOK       = not useVolumeFilter or isVolumeSpike

bodySize = math.abs(close - open)
fullSize = high - low
isMomentumCandle = fullSize > 0 and bodySize / fullSize * 100 >= candleBodyRatio
candleOK        = not useCandleFilter or isMomentumCandle

rsiShiftOK_L = not useRSIShift or htfRsi >= rsiBullBand
rsiShiftOK_S = not useRSIShift or htfRsi <= rsiBearBand

eqSlope = ta.linreg(strategy.equity, eqSlopeLen, 0) - ta.linreg(strategy.equity, eqSlopeLen, 1)
equitySlopeOK_L = not useEquitySlopeFilter or eqSlope >= 0
equitySlopeOK_S = not useEquitySlopeFilter or eqSlope <= 0

contextLongOK = microTrendLong and trendBiasLongOK and confBiasLongOK and slopeOK_L and rangeOK and vwapLong and distanceOK_L and momOK_L and chochOK_L and volumeOK and candleOK and rsiShiftOK_L and htfLong and equitySlopeOK_L
contextShortOK = microTrendShort and trendBiasShortOK and confBiasShortOK and slopeOK_S and rangeOK and vwapShort and distanceOK_S and momOK_S and chochOK_S and volumeOK and candleOK and rsiShiftOK_S and htfShort and equitySlopeOK_S

var float pivLowCache  = na
var float pivHighCache = na
if usePivotSL
    lastPivotLow  = ta.valuewhen(not na(ta.pivotlow(low, pivLeft, pivRight)), ta.pivotlow(low, pivLeft, pivRight), 0)
    lastPivotHigh = ta.valuewhen(not na(ta.pivothigh(high, pivLeft, pivRight)), ta.pivothigh(high, pivLeft, pivRight), 0)
    if not na(lastPivotLow)
        pivLowCache := lastPivotLow - atrBufferMult * atrStop
    if not na(lastPivotHigh)
        pivHighCache := lastPivotHigh + atrBufferMult * atrStop

calcNotionalQty() =>
    baseEquity = tradableCapital
    sizeUsd = notionalSizingType == "Fixed USD" ? notionalSizingValue : baseEquity * (notionalSizingValue / 100.0)
    riskScale = baseRiskPct > 0 ? finalRiskPct / baseRiskPct : 1.0
    adjSizeUsd = math.max(sizeUsd * riskScale, 0.0)
    close > 0 ? (adjSizeUsd * leverage) / close : na

calcRiskQty(stopDistance) =>
    if na(stopDistance) or stopDistance <= 0
        na
    else
        riskSizingType == "Fixed Fractional" ? (tradableCapital * finalRiskPct / 100.0) / stopDistance : fixedContractSize

calcPositionQty(stopDistance) =>
    qtyRisk = calcRiskQty(stopDistance)
    qtyNotional = calcNotionalQty()
    qtySelected = positionSizingMode == "Risk-Based" ? qtyRisk : qtyNotional
    na(qtySelected) ? 0.0 : math.max(qtySelected, 0.0)

isTimeAllowed = inDate and sessionAllowed and kstAllowed and dayAllowed
haltReasons = isCapitalBreached or isGuardHalted or stop_by_losses or stop_by_dd or stop_by_guard or stop_by_capital or stop_by_streak or stop_by_perf or stop_by_profit
kasia_canTrade     = isTimeAllowed and not haltReasons and isVolatilityOK

// =====================================================================
// PPP Vishva Algo 핵심 계산
// =====================================================================

ma100 = ma(close, maType, 100)
dirLong  = not useMA100 or close > ma100
dirShort = not useMA100 or close < ma100

ut_src = utHA
    ? request.security(haTicker, timeframe.period, close, lookahead=barmerge.lookahead_off)
    : close
xATR  = ta.atr(int(utAtrEff))
nLoss = utKeyEff * xATR
var float trail = na
trail := na(trail[1]) ? (ut_src - nLoss) :
     (ut_src > trail[1] and ut_src[1] > trail[1] ? math.max(trail[1], ut_src - nLoss) :
     (ut_src < trail[1] and ut_src[1] < trail[1] ? math.min(trail[1], ut_src + nLoss) :
     (ut_src > trail[1] ? ut_src - nLoss : ut_src + nLoss)))
ema1  = ta.ema(ut_src,1)
utBuy  = (ut_src > trail) and ta.crossover(ema1, trail)
utSell = (ut_src < trail) and ta.crossover(trail, ema1)

stoch_rsi(_src,_rsi,_st,_k,_d)=>
    _r = ta.rsi(_src,_rsi)
    _kv = ta.sma(ta.stoch(_r, _r, _r, _st), _k)
    _dv = ta.sma(_kv, _d)
    [_kv,_dv]
[k_cur, d_cur] = stoch_rsi(close, rsiLen, stLen, kLen, dLen)
k_htf = request.security(syminfo.tickerid, tf_stoch, k_cur,  lookahead=barmerge.lookahead_off)
d_htf = request.security(syminfo.tickerid, tf_stoch, d_cur,  lookahead=barmerge.lookahead_off)
stLong = stMode=="Bounce" ? (k_htf < osEff and ta.crossover(k_htf, d_htf)) : ta.crossover(k_htf, d_htf) and k_htf < 50
stShort= stMode=="Bounce" ? (k_htf > obEff and ta.crossunder(k_htf, d_htf)) : ta.crossunder(k_htf, d_htf) and k_htf > 50

htf1_conf = request.security(syminfo.tickerid, tf_htf1, barstate.isconfirmed, lookahead=barmerge.lookahead_off)
htf2_conf = request.security(syminfo.tickerid, tf_htf2, barstate.isconfirmed, lookahead=barmerge.lookahead_off)
ha1 = haClose(tf_htf1)
e1  = ema20(tf_htf1)
ha2 = haClose(tf_htf2)
e2  = ema20(tf_htf2)
trendLong  = (ha1 > e1 and ha2 > e2)
trendShort = (ha1 < e1 and ha2 < e2)

regClose  = request.security(regSym, regTF, close, lookahead=barmerge.lookahead_off)
regEMA200 = request.security(regSym, regTF, ta.ema(close,200), lookahead=barmerge.lookahead_off)
regADXv   = request.security(regSym, regTF, f_adx(14), lookahead=barmerge.lookahead_off)
regLongOK  = not useReg or (regClose > regEMA200 and regADXv >= regADX)
regShortOK = not useReg or (regClose < regEMA200 and regADXv >= regADX)

ewoRaw = calcEWO(close, ewoFast, ewoSlow)
ewoSig = ta.ema(ewoRaw, ewoSignal)
EWO_long  = not useEWO or (ewoRaw < 0 and ta.crossunder(ewoRaw, ewoSig))
EWO_short = not useEWO or (ewoRaw > 0 and ta.crossover(ewoRaw, ewoSig))

chop = calcChop(chopLen)
chopOK = not useChop or chop <= chopMax

atrPerc = calcAtrPerc(14)
volOK   = not useVolatility or (atrPerc >= minAtrPerc and atrPerc <= maxAtrPerc)

volAvg = ta.sma(volume, volLen)
volPass = not useVolumeBoost or (volume >= volAvg)

highestStruct = ta.highest(high, structureLen)
lowestStruct  = ta.lowest(low, structureLen)
structureLongOK  = not useStructure or close > highestStruct
structureShortOK = not useStructure or close < lowestStruct

var bool armedL = false
var bool armedS = false
if barstate.isnew
    armedL := false
    armedS := false

baseLong  = utBuy  and stLong  and dirLong  and trendLong  and regLongOK and EWO_long and chopOK and volOK and volPass and structureLongOK
baseShort = utSell and stShort and dirShort and trendShort and regShortOK and EWO_short and chopOK and volOK and volPass and structureShortOK

htfOK = (not noRP) or (htf1_conf and htf2_conf)
longSig  = (noRP ? baseLong  and htfOK and barstate.isconfirmed : baseLong  and htfOK)
shortSig = (noRP ? baseShort and htfOK and barstate.isconfirmed : baseShort and htfOK)
longFire  = ibs ? (baseLong  and htfOK and not armedL)  : longSig
shortFire = ibs ? (baseShort and htfOK and not armedS) : shortSig
if ibs and baseLong  and htfOK
    armedL := true
if ibs and baseShort and htfOK
    armedS := true

var int cooldownCounter = 0
if strategy.closedtrades > strategy.closedtrades[1]
    lastIdx = strategy.closedtrades - 1
    if strategy.closedtrades.profit(lastIdx) < 0
        cooldownCounter := lossCooldownBars
if cooldownCounter > 0 and barstate.isnew
    cooldownCounter -= 1
cooldownActive = cooldownCounter > 0

var int dailyTradeCount = 0
if aNewDay
    dailyTradeCount := 0

newTradePossible = maxTradesPerDay == 0 or dailyTradeCount < maxTradesPerDay

kasia_contextLong = contextLongOK
kasia_contextShort = contextShortOK

canLong  = kasia_canTrade and kasia_contextLong and longFire  and strategy.position_size <= 0 and not cooldownActive and newTradePossible
canShort = kasia_canTrade and kasia_contextShort and shortFire and strategy.position_size >= 0 and not cooldownActive and newTradePossible

// =====================================================================
// 진입/청산 엔진
// =====================================================================

atrVal = ta.atr(atrLen)
longSwingRef  = useSwingSL ? ta.lowest(low, swN) : na
shortSwingRef = useSwingSL ? ta.highest(high, swN) : na

calcInitialLongStop(entryPrice)=>
    swing = useSwingSL and not na(longSwingRef) ? longSwingRef : na
    base = entryPrice - initKEff * atrVal
    if useSwingSL and not na(swing)
        math.min(base, swing)
    else
        base

calcInitialShortStop(entryPrice)=>
    swing = useSwingSL and not na(shortSwingRef) ? shortSwingRef : na
    base = entryPrice + initKEff * atrVal
    if useSwingSL and not na(swing)
        math.max(base, swing)
    else
        base

requestLongQty(entryPrice)=>
    stopLevel = calcInitialLongStop(entryPrice)
    stopDist  = entryPrice - stopLevel
    qty = stopDist > 0 ? calcPositionQty(stopDist + slipBuffer) : 0.0
    qty >= minQty ? qty : 0.0

requestShortQty(entryPrice)=>
    stopLevel = calcInitialShortStop(entryPrice)
    stopDist  = stopLevel - entryPrice
    qty = stopDist > 0 ? calcPositionQty(stopDist + slipBuffer) : 0.0
    qty >= minQty ? qty : 0.0

if canLong
    qtyL = requestLongQty(close)
    if qtyL > 0
        strategy.entry("L", strategy.long, qty=qtyL)
        dailyTradeCount += 1

if canShort
    qtyS = requestShortQty(close)
    if qtyS > 0
        strategy.entry("S", strategy.short, qty=qtyS)
        dailyTradeCount += 1

longSwingSL  = useSwingSL ? longSwingRef : na
shortSwingSL = useSwingSL ? shortSwingRef : na

longSL_atr  = strategy.position_avg_price - initKEff * atrVal
shortSL_atr = strategy.position_avg_price + initKEff * atrVal

long_refSL  = strategy.position_size > 0 ? (useSwingSL and not na(longSwingSL) ? longSwingSL : longSL_atr)   : na
short_refSL = strategy.position_size < 0 ? (useSwingSL and not na(shortSwingSL) ? shortSwingSL : shortSL_atr) : na

longR   = strategy.position_size > 0 and not na(long_refSL)  ? (strategy.position_avg_price - long_refSL)  : na
shortR  = strategy.position_size < 0 and not na(short_refSL) ? (short_refSL - strategy.position_avg_price) : na

longTP1  = strategy.position_size > 0 and not na(longR)  ? strategy.position_avg_price + tp1RREff * longR  : na
longTP2  = strategy.position_size > 0 and not na(longR)  ? strategy.position_avg_price + tp2RREff * longR  : na
shortTP1 = strategy.position_size < 0 and not na(shortR) ? strategy.position_avg_price - tp1RREff * shortR : na
shortTP2 = strategy.position_size < 0 and not na(shortR) ? strategy.position_avg_price - tp2RREff * shortR : na

var bool hitTP1L = false
var bool hitTP1S = false
hitTP1L := (hitTP1L and strategy.position_size > 0) or (strategy.position_size > 0 and not na(longTP1)  and high >= longTP1)
hitTP1S := (hitTP1S and strategy.position_size < 0) or (strategy.position_size < 0 and not na(shortTP1) and low  <= shortTP1)

beOffset = beOffsetEff / 100.0

longStopBE = strategy.position_avg_price * (1 + beOffset)
shortStopBE = strategy.position_avg_price * (1 - beOffset)

trailStopLong = close - trailKEff * atrVal
trailStopShort = close + trailKEff * atrVal

longStop = strategy.position_size > 0 ? (     hitTP1L ? math.max(longStopBE, trailStopLong) : long_refSL) : na
shortStop = strategy.position_size < 0 ? (    hitTP1S ? math.min(shortStopBE, trailStopShort) : short_refSL) : na

percentStopLong  = strategy.position_size > 0 ? strategy.position_avg_price * (1 - stopPctEff / 100.0) : na
percentStopShort = strategy.position_size < 0 ? strategy.position_avg_price * (1 + stopPctEff / 100.0) : na
percentTakeLong  = strategy.position_size > 0 ? strategy.position_avg_price * (1 + takePctEff / 100.0) : na
percentTakeShort = strategy.position_size < 0 ? strategy.position_avg_price * (1 - takePctEff / 100.0) : na

trailTriggerLong = strategy.position_size > 0 and close >= strategy.position_avg_price * (1 + trailStartEff / 100.0)
trailTriggerShort= strategy.position_size < 0 and close <= strategy.position_avg_price * (1 - trailStartEff / 100.0)
trailPct = trailGapEff / 100.0
var float trailStopPctLongCache = na
var float trailStopPctShortCache = na

trailStopPctLongCurrent  = close * (1 - trailPct)
trailStopPctShortCurrent = close * (1 + trailPct)

if not trailTriggerLong
    trailStopPctLongCache := na
else
    trailStopPctLongCache := na(trailStopPctLongCache) ? trailStopPctLongCurrent : math.max(trailStopPctLongCache, trailStopPctLongCurrent)

if not trailTriggerShort
    trailStopPctShortCache := na
else
    trailStopPctShortCache := na(trailStopPctShortCache) ? trailStopPctShortCurrent : math.min(trailStopPctShortCache, trailStopPctShortCurrent)

trailStopPctLong  = trailStopPctLongCache
trailStopPctShort = trailStopPctShortCache

barsInTrade = strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(0) : na
tradeMinutes = strategy.opentrades > 0 ? (timenow - strategy.opentrades.entry_time(0)) / 60000 : na
roiHitLong = strategy.position_size > 0 and not na(tradeMinutes) and (
     (roi1MinEff > 0 and tradeMinutes >= roi1MinEff and close >= strategy.position_avg_price * (1 + roi1PctEff / 100.0)) or
     (roi2MinEff > 0 and tradeMinutes >= roi2MinEff and close >= strategy.position_avg_price * (1 + roi2PctEff / 100.0)) or
     (roi3MinEff > 0 and tradeMinutes >= roi3MinEff and close >= strategy.position_avg_price * (1 + roi3PctEff / 100.0)))
roiHitShort = strategy.position_size < 0 and not na(tradeMinutes) and (
     (roi1MinEff > 0 and tradeMinutes >= roi1MinEff and close <= strategy.position_avg_price * (1 - roi1PctEff / 100.0)) or
     (roi2MinEff > 0 and tradeMinutes >= roi2MinEff and close <= strategy.position_avg_price * (1 - roi2PctEff / 100.0)) or
     (roi3MinEff > 0 and tradeMinutes >= roi3MinEff and close <= strategy.position_avg_price * (1 - roi3PctEff / 100.0)))

maxBarsHit = maxBarsHoldEff > 0 and not na(barsInTrade) and barsInTrade >= maxBarsHoldEff

if strategy.position_size > 0
    stopFinal = longStop
    if usePercentStops and not na(percentStopLong)
        stopFinal := math.max(stopFinal, percentStopLong)
    if not na(trailStopPctLong)
        stopFinal := math.max(stopFinal, trailStopPctLong)
    strategy.exit("L-TP1", from_entry="L", limit=longTP1, stop=stopFinal, qty_percent=tp1PctEff)
    strategy.exit("L-TP2", from_entry="L", limit=longTP2, stop=stopFinal, qty_percent=100 - tp1PctEff)
    if usePercentStops and not na(percentTakeLong)
        strategy.exit("L-TPpct", from_entry="L", limit=percentTakeLong, stop=stopFinal, qty_percent=100)
    if roiHitLong or maxBarsHit
        strategy.close("L", comment="ROI/Time")

if strategy.position_size < 0
    stopFinal = shortStop
    if usePercentStops and not na(percentStopShort)
        stopFinal := math.min(stopFinal, percentStopShort)
    if not na(trailStopPctShort)
        stopFinal := math.min(stopFinal, trailStopPctShort)
    strategy.exit("S-TP1", from_entry="S", limit=shortTP1, stop=stopFinal, qty_percent=tp1PctEff)
    strategy.exit("S-TP2", from_entry="S", limit=shortTP2, stop=stopFinal, qty_percent=100 - tp1PctEff)
    if usePercentStops and not na(percentTakeShort)
        strategy.exit("S-TPpct", from_entry="S", limit=percentTakeShort, stop=stopFinal, qty_percent=100)
    if roiHitShort or maxBarsHit
        strategy.close("S", comment="ROI/Time")

if utFlipExit and strategy.position_size > 0 and utSell
    strategy.close("L", comment="UT Flip")
if utFlipExit and strategy.position_size < 0 and utBuy
    strategy.close("S", comment="UT Flip")

if eodClose and strategy.position_size != 0
    eodHour = str.tonumber(str.substring(eodTime, 0, 2))
    eodMinute = str.tonumber(str.substring(eodTime, 3, 5))
    if hour == eodHour and minute >= eodMinute
        strategy.close_all(comment="EOD Close")

// =====================================================================
// HUD / 디버거 / 플롯
// =====================================================================

plot(trail, "UT Trailing", color=color.new(color.yellow, 0))
plot(ma100, "MA100", color=color.new(color.teal, 0))
plot(useMicroTrend ? emaFast : na, "EMA 빠른선", color=color.new(color.aqua, 0))
plot(useMicroTrend ? emaSlow : na, "EMA 느린선", color=color.new(color.orange, 0))
plot(usePivotSL ? pivLowCache : na, "Pivot SL Long", color=color.new(color.red, 0), style=plot.style_linebr)
plot(usePivotSL ? pivHighCache : na, "Pivot SL Short", color=color.new(color.red, 0), style=plot.style_linebr)
plot(useVWAPFilter ? vwap : na, "VWAP", color=color.new(color.yellow, 40))

plotshape(utBuy,  "UT Buy",  shape.triangleup,   location.belowbar, color.new(color.lime,0), size=size.tiny, text="UT▲")
plotshape(utSell, "UT Sell", shape.triangledown, location.abovebar, color.new(color.red ,0), size=size.tiny, text="UT▼")

if showHUD and barstate.islast
    posMap = switch hudPosition
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Middle Left" => position.middle_left
        "Middle Right" => position.middle_right
        "Bottom Left" => position.bottom_left
        => position.bottom_right
    var table hud = table.new(posMap, 2, 14, bgcolor=color.new(color.black, 40), border_width=1, border_color=color.gray)
    table.cell(hud, 0, 0, "KCAS HUD", text_color=color.white, bgcolor=color.new(color.purple, 20))
    table.cell(hud, 1, 0, "", bgcolor=color.new(color.purple, 20))
    table.merge_cells(hud, 0, 0, 1, 0)
    table.cell(hud, 0, 1, "거래 가능 자본", text_color=color.white)
    table.cell(hud, 1, 1, f_str(tradableCapital), text_color=color.aqua)
    table.cell(hud, 0, 2, "적립된 수익", text_color=color.white)
    table.cell(hud, 1, 2, f_str(withdrawable), text_color=color.yellow)
    winrate = strategy.wintrades + strategy.losstrades == 0 ? 0 : strategy.wintrades / (strategy.wintrades + strategy.losstrades) * 100
    totalPnlColor = strategy.netprofit >= 0 ? color.lime : color.red
    table.cell(hud, 0, 3, "승률 / 누적PnL", text_color=color.white)
    table.cell(hud, 1, 3, str.tostring(winrate, "##.##") + "% / " + f_str(strategy.netprofit), text_color=totalPnlColor)
    dailyTargetTxt = useDailyProfitLock ? f_str(dailyProfitTarget) : "OFF"
    dailyTargetColor = dailyProfitReached ? color.lime : dailyPnl >= 0 ? color.aqua : color.red
    table.cell(hud, 0, 4, "일일 PnL / 목표", text_color=color.white)
    table.cell(hud, 1, 4, f_str(dailyPnl) + " / " + dailyTargetTxt, text_color=dailyTargetColor, bgcolor=color.new(dailyTargetColor, dailyProfitReached ? 40 : 75))
    weeklyTargetTxt = useWeeklyProfitLock ? f_str(weeklyProfitTarget) : "OFF"
    weeklyTargetColor = weeklyProfitReached ? color.lime : weeklyPnl >= 0 ? color.aqua : color.red
    table.cell(hud, 0, 5, "주간 PnL / 목표", text_color=color.white)
    table.cell(hud, 1, 5, f_str(weeklyPnl) + " / " + weeklyTargetTxt, text_color=weeklyTargetColor, bgcolor=color.new(weeklyTargetColor, weeklyProfitReached ? 40 : 75))
    atrStatusColor = isVolatilityOK ? color.new(color.aqua, 60) : color.new(color.red, 40)
    table.cell(hud, 0, 6, "ATR% 상태", text_color=color.white)
    table.cell(hud, 1, 6, str.tostring(atrPct, "##.##") + "% / " + str.tostring(volatilityLowerPct, "##.##") + "%-" + str.tostring(volatilityUpperPct, "##.##") + "%", text_color=isVolatilityOK ? color.aqua : color.red, bgcolor=atrStatusColor)
    haltText  = haltReasons ? "중지" : "가동"
    haltColor = haltReasons ? color.red : color.green
    table.cell(hud, 0, 7, "거래 상태", text_color=color.white)
    table.cell(hud, 1, 7, haltText, text_color=color.white, bgcolor=color.new(haltColor, 60))
    maxDailyTxt = maxDailyLosses > 0 ? str.tostring(maxDailyLosses) : "∞"
    table.cell(hud, 0, 8, "일일 손실", text_color=color.white)
    table.cell(hud, 1, 8, str.tostring(dailyLosses) + "/" + maxDailyTxt, text_color=stop_by_losses ? color.red : color.white)
    table.cell(hud, 0, 9, "주간 DD", text_color=color.white)
    table.cell(hud, 1, 9, str.tostring(weeklyDD, "##.##") + "% / " + str.tostring(maxWeeklyDD, "##.##") + "%", text_color=stop_by_dd ? color.red : color.white)
    maxGuardTxt = maxGuardFires > 0 ? str.tostring(maxGuardFires) : "∞"
    table.cell(hud, 0, 10, "청산 가드", text_color=color.white)
    table.cell(hud, 1, 10, str.tostring(guardFiredTotal) + "/" + maxGuardTxt, text_color=stop_by_guard ? color.red : color.white)
    table.cell(hud, 0, 11, "연패 상태", text_color=color.white)
    table.cell(hud, 1, 11, str.tostring(lossStreak) + "/" + str.tostring(maxConsecutiveLosses), text_color=stop_by_streak ? color.red : color.white)
    parColor = not usePerfAdaptiveRisk ? color.gray : isHotStreak ? color.new(color.orange, 20) : isColdStreak ? color.new(color.blue, 20) : color.new(color.silver, 40)
    table.cell(hud, 0, 12, "프리셋 / UT", text_color=color.white)
    table.cell(hud, 1, 12, presetMode + " / K=" + str.tostring(utKeyEff, "#.##") + " / ATR=" + str.tostring(utAtrEff), text_color=color.white)
    table.cell(hud, 0, 13, "PAR 상태", text_color=color.white)
    table.cell(hud, 1, 13, parStateLabel + " / " + parWinLabel + " / " + str.tostring(finalRiskPct, "#.##") + "%", text_color=color.white, bgcolor=parColor)

if showDebugger and barstate.islast
    var table dbg = table.new(position.bottom_right, 3, 15, bgcolor=color.new(color.black, 40), border_width=1, border_color=color.gray)
    headerDbgBg = color.new(color.blue, 40)
    table.cell(dbg, 0, 0, "디버거", text_color=color.white, bgcolor=headerDbgBg)
    table.cell(dbg, 1, 0, "", bgcolor=headerDbgBg)
    table.cell(dbg, 2, 0, "", bgcolor=headerDbgBg)
    table.merge_cells(dbg, 0, 0, 2, 0)
    table.cell(dbg, 0, 1, "시간 필터", text_color=color.white)
    f_cell(dbg, 1, 1, isTimeAllowed)
    table.cell(dbg, 0, 2, "레짐 L/S", text_color=color.white)
    table.cell(dbg, 1, 2, str.tostring(htfLong) + "/" + str.tostring(htfShort), text_color=color.white)
    table.cell(dbg, 0, 3, "마이크로 트렌드", text_color=color.white)
    table.cell(dbg, 1, 3, str.tostring(microTrendLong) + "/" + str.tostring(microTrendShort), text_color=color.white)
    table.cell(dbg, 0, 4, "EMA 기울기", text_color=color.white)
    table.cell(dbg, 1, 4, str.tostring(slopePct, "#.##") + "%", text_color=slopeOK_L ? color.aqua : color.red)
    table.cell(dbg, 0, 5, "VWAP", text_color=color.white)
    f_cell(dbg, 1, 5, vwapLong)
    table.cell(dbg, 0, 6, "모멘텀", text_color=color.white)
    f_cell(dbg, 1, 6, momOK_L)
    f_cell(dbg, 2, 6, momOK_S)
    table.cell(dbg, 0, 7, "CHoCH", text_color=color.white)
    f_cell(dbg, 1, 7, chochOK_L)
    f_cell(dbg, 2, 7, chochOK_S)
    table.cell(dbg, 0, 8, "볼륨", text_color=color.white)
    f_cell(dbg, 1, 8, volumeOK)
    table.cell(dbg, 0, 9, "캔들", text_color=color.white)
    f_cell(dbg, 1, 9, candleOK)
    table.cell(dbg, 0, 10, "레인지/ATR", text_color=color.white)
    f_cell(dbg, 1, 10, rangeOK)
    f_cell(dbg, 2, 10, isVolatilityOK)
    table.cell(dbg, 0, 11, "거래 중지", text_color=color.white)
    f_cell(dbg, 1, 11, not haltReasons)
    table.cell(dbg, 0, 12, "가드 카운터", text_color=color.white)
    table.cell(dbg, 1, 12, str.tostring(guardFiredTotal) + "/" + str.tostring(maxGuardFires), text_color=stop_by_guard ? color.red : color.white)
    table.cell(dbg, 0, 13, "DD & ATR%", text_color=color.white)
    table.cell(dbg, 1, 13, str.tostring(weeklyDD, "##.##") + "% / " + str.tostring(atrPct, "##.##") + "%", text_color=color.white)
    table.cell(dbg, 0, 14, "컨텍스트", text_color=color.white)
    table.cell(dbg, 1, 14, str.tostring(contextLongOK) + "/" + str.tostring(contextShortOK), text_color=color.white)

// =====================================================================
// Alerts (3Commas 연동용)
// =====================================================================

makeJSON(_action, _side)=>
    str.format('{{"action":"{0}","side":"{1}","symbol":"{2}","leverage":{3},"cap_pct":{4}}}',
      _action, _side, syminfo.ticker, leverage, default_qty_value)

longOpen   = canLong
shortOpen  = canShort
longClose  = strategy.position_size > 0 and (shortSig or (not na(longStop)  and low  <= longStop))
shortClose = strategy.position_size < 0 and (longSig  or (not na(shortStop) and high >= shortStop))

alertcondition(longOpen,  title="LONG_ENTRY",  message=makeJSON("open","long"))
alertcondition(shortOpen, title="SHORT_ENTRY", message=makeJSON("open","short"))
alertcondition(longClose, title="LONG_EXIT",   message=makeJSON("close","long"))
alertcondition(shortClose,title="SHORT_EXIT",  message=makeJSON("close","short"))

if longOpen
    alert(makeJSON("open","long"), alert.freq_once_per_bar)
if shortOpen
    alert(makeJSON("open","short"), alert.freq_once_per_bar)
if longClose
    alert(makeJSON("close","long"), alert.freq_once_per_bar)
if shortClose
    alert(makeJSON("close","short"), alert.freq_once_per_bar)
